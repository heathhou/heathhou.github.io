---
title: JavaCare
date: 2020-06-28 16:57:06
top: 5
tags: [java]
declare: true
---




本文记录了我在学习Java的时候容易混淆与遗忘的知识。

<!-- more -->

# 一、基础知识（大部分与C相同）

## 1.1 关键字：（大部分与C相同）

1. **概念**：关键字是被Java语言赋予特殊含义，具有专门用途的单词。

   比如class，public，static，void均为Java已经预设好的。
2. 特点：
   - 完全由小写字母组成；
   - 在增强版记事本（例如Notepad++）当中有特殊颜色

3. Java中所有的关键字列表：（现阶段不要背，随着学习内容逐步深入，慢慢了解含义）。

## 1.2 常量

1. 概念：程序运行期间，固定不变的量。

2. **分类**：

3. 字符串常量，使用英文双引号引起来的内容。

-  整数常量，例如100、120、-250等。
-  浮点数（小数）常量，例如3.14、-2.5等。
-  字符常量，使用英文单引号引起来的单个字符，例如’A’、’b’、’中’等。必须有且仅有一个字符。
-  布尔常量，只有两种取值：true和false。通常用于条件判断和流程控制。

4. 定义常量：例如：**public static final ** MAX = 1024；

## 1.3 标识符

1. 作用：给类、变量、包、方法等起名字。

2. 组成规则（硬性规定）

  - 只能由字符、下划线_、美元符$组成。这里的字符包括大小写字母、中文字符、数字字符等，但符号只能有两个：下划线_和美元符$；（C只有英文字母，数字，下划线）
  - 不能以数字开头。
  - 不能是Java中的关键字。

3. 命名规则（软性建议）

  - 基本要求：见名知意。
  - 建议只使用英文字母和数字。
  - 常见命名的规则：

```
1. 类 : 每个单词首字母大写，例如Student、HelloWorld。

2. 变量 : 第一个单词完全小写，后续更多单词首字母大写，例如age、ageOfMyGirlfriend。

3. 方法 : 与变量规则一样，例如show()、getAge()。

4. 包（其实就是文件夹，用于对类进行管理）: 
	全部小写，多级包用点隔开。公司域名的反写。
    cn.itcast     （相当于两级文件夹：cn\itcast）
    com.itheima    （相当于两级文件夹：com\itheima）

```



## 1.4 数据类型：（与C语言有点不同）

1. 在Java 9（2017年9月发布）或更早版本的JDK中，数据类型只有两种。

2. **基本类型**，包括8种：byte、short、int、long、float、double、char、boolean。

3. **引用类型**（除了基本，都算引用），包括：数组、类、接口、Lambda等。

4. 其中的8种基本数据类型:



![](https://cdn.jsdelivr.net/gh/heathhou/image_store/分类/Java/java_care/20200628173601.png)

5. 注意事项：

- 整数类型有4种，默认为int类型。
- 浮点数类型有2种，默认为double类型。
- 定义一个long型数据，在数值后面要用字母L作为后缀（大小写均可，推荐大写）。5200000000L。
- 定义一个float型数据，在数值后面要用字母F作为后缀（大小写均可，推荐大写）。3.14F。
- 字符char型数据，占据2个字节，是可以包含中文的。

## 1.5 运算

1. 取模运算：只有对整数使用取模运算，才有余数的数学意义。

2. 比较运算符：用于比较两个数据的关系，运算结果一定是boolean型数据。

3. 强制转换注意事项

- 强制类型转换一般不推荐使用，因为有可能发生精度损失、数据溢出。
- byte/short/char这三种类型都可以发生数学运算，例如加法“+”.
- byte/short/char这三种类型在运算的时候，都会被首先提升成为int类型，然后再计算。
- boolean类型不能发生数据类型转换



# 二、数组

## 2.1 数组的默认规则

1. 数组元素的默认值规则为：

- 整数默认为0，浮点数默认为0.0，字符默认为’\u0000’（Unicode写法），布尔值默认为false，字符串等其他引用类型默认为null。



## 2.2 数组的初始化方式

1. 动态初始化，指定数组的长度。：

  ```java
  直接指定数组的长度，也就是数组当中到底可以存放多少个数据。

  数据类型[] 数组名称 = new 数据类型[数组长度];

  数据类型[] 数组名称; 数组名称 = new 数据类型[数组长度];
  ```

2. 静态初始化，指定数组的内容。：
  ```java
  静态初始化不会直接指定长度，而是直接指定具体的元素内容。

  数据类型[] 数组名称 = new 数据类型[] { 元素1, 元素2, 元素3, ... };

  数据类型[] 数组名称; 数组名称 = new 数据类型[] {...};
  ```

3. 简便格式：

```java
数据类型[] 数组名称 = { 元素1, 元素2, 元素3, ... };
```

一旦使用了简便格式，必须一个步骤完成初始化，不能拆分成为两个步骤。

## 2.3 数组的注意事项

1. 数组属于引用类型

2. 注意，数组在内存当中一旦被创建，那么**长度不可改变**。



# 三、方法（函数）

## 3.1 静态方法 

1. 静态方法不属于对象，属于类。

2. 静态不能直接访问非静态。

3. 静态方法中不能使用this关键字。

4. 方法内不能直接定义静态成员。

## 3.2 方法的覆盖与重载 

1. 方法覆盖重写的注意事项：
   - @Override
   - 方法的签名必须相同
   - 子类的返回值必须【小于等于】父类方法的返回值范围。
   - 子类不能抛出新的异常。
   - 子类方法的权限必须【大于等于】父类方法的权限修饰符。


2. 重写（Override）：方法的名称一样，参数列表【也一样】。覆盖、重写。

3. 重载（Overload）：方法的名称一样，参数列表【不一样】。

## 3.3 方法的注意事项

1. 方法的参数和返回值可以是任何类型，无论是基本类型，还是引用类型中的数组、字符串甚至是自定义的类，都可以作为方法的参数和返回值。

2. null.equals(str),会有异常。

3. 可变参数的注意事项：
   - 一个方法的参数列表，只能有一个可变参数。
   - 如果方法的参数有多个，那么可变参数必须写在参数列表的末尾。

## 3.4 字符串方法的使用 

1. 字符串替换方法：public String replace(CharSequence oldStr, CharSequence newStr)

   字符串对象一旦被创建，内容不可改变。

   如果希望替换字符串当中的内容，则可以使用方法：

   `public String replace(CharSequence oldStr, CharSequence newStr)`

   其中CharSequence现阶段可以简单地认为就是String字符串。而oldStr代表需要被替换的老   字符串，newStr代表需要替换成为的新字符串。

   注意，replace方法会将结果作为一个新的字符串返回。

2. 字符串切割方法：

   `public String[] split(String regex)`

   如果希望将字符串按照指定的标记切分成为若干段儿，可以使用方法：

   public String[] split(String regex)：
   
   参数regex代表切割标记，返回值是字符串切割后成为的字符串数组。

   注意，强烈推荐现阶段使用英文逗号作为切割标记，不要使用英文句点，因为英文句点在正则表达式（今后学习）中有特殊含义。

3. 字符串对象一旦被创建，内容不可改变。

# 四、访问权限

## 4.1 文字

- private： 私有的权限，只对本类的方法可以使用；
- 包访问权限（default）： 只对同包的类具有访问的权限，外包的所有类都不能访问；
- protected： 这种权限是为继承而设计的，protected所修饰的成员，对所有子类是可访问的，但只对同包的类是可访问的，对外包的非子类是不可以访问；
- public： 所修饰的类、变量、方法，在内外包均具有访问权限；



## 4.2 表格

| 访问权限  | 访问权限的作用范围 |
| --------- | ------------------ |
| private   | 同一类             |
| 默认      | 类，包             |
| protected | 类，子类，包       |
| public    | 全部               |



## 4.3 图片

![](https://cdn.jsdelivr.net/gh/heathhou/image_store/分类/Java/java_care/20200628180028.png)

## 4.4 四种权限修饰符

|                        | private | (default) | protected | public |
| ---------------------- | ------- | --------- | --------- | ------ |
| 同一个类（我自己）     | YES     | YES       | YES       | YES    |
| 同一个包（我邻居）     | NO      | YES       | YES       | YES    |
| 不同包子类（我儿子）   | NO      | NO        | YES       | YES    |
| 不同包非子类（陌生人） | NO      | NO        | NO        | YES    |





# 五、类，封装

## 5.1 abstract抽象类

1. 所有的抽象类不能生成对象实例，抽象类不能用关键字final修饰。

2. 抽象方法所在的类必须是抽象类。

3. 不能直接创建new 抽象类

4. 必须用一个子类来继承抽象父类

5. 子类必须覆盖重写抽象父类当中的所有的抽象方法，除非子类也是抽象类

6. 抽象类中可以有构造方法，是提供子类创建对象时，初始化父类成员使用的

7. 抽象类中，不一定包含抽象方法，但有抽象方法的类必须是抽象类



## 5.2 java内存分配

- 栈（Stack）：主要用来存放局部变量。
- 堆（Heap）：凡是new出来的东西，都在堆当中。堆当中的数据有默认值规则：
  - 如果是整数，默认是0；
  - 如果是浮点数，默认是0.0；
  - 如果是字符，默认是’\u0000’（Unicode写法）；
  - 如果是布尔值，默认为false；
  - 如果是引用类型（包含字符串），默认为null（空常量）。
- 方法区（Method Area）：存放与.class相关的信息。
- 本地方法区（Native Method Area）：与操作系统相关。
- 寄存器（pc Register）：与CPU相关，性能极高。

## 5.3 重名问题 

1. 当局部变量和成员变量重名的时候，方法当中会根据“就近原则”使用局部变量。



## 5.4 静态相关

1. 静态代码块：

   - 用来一次性的对静态成员变量进行赋值。
   - 当第一次用到本类时，静态代码块执行的唯一一次。

2. 无论是成员变量，还是成员方法。如果有了static，都推荐使用类名称进行调用。

   - 静态变量：类名称.静态变量
   - 静态方法：类名称.静态方法（）

3. 静态不能直接访问非静态。
   - 原因：因为在内存当中是[先]有的静态内容，[后]有的非静态内容。
   - “先人不知道后人，但是后人知道先人。”

4. 静态方法当中不能用this。

   - 原因：this代表当前对象，通过谁调用的方法，谁就是当前对象。而静态跟对象无关。



## 5.5 注意事项

1. 在一个源程序中最多允许一个类使用public修饰符。

2. 在一个源程序中，public类名==文件名（后缀.java）。

3. 在一个源程序中，构造方法名==所在类名。

4. 在类中执行顺序：域->静态初始化器->实例初始化器->构造方法。
   - （父类静态初始化器->子类静态初始化器）
   - 父类的实例初始化器->父类的构造方法->子类的实例初始化器->子类的构造方法；

5. 父类与子类：无论是成员方法还是成员变量，如果没有都是向上找父类，绝对不会向下找子类的。

6. 只有在类的域中定义的变量（成员变量）不初始化会被默认为0。
   - 局部变量：没有默认值，必须赋值之后才能使用 
   - 成员变量：如果没有赋值，那么将会有一个默认值。、



# 六、内部类

## 6.1 成员内部类与局部内部类

- 注意：内用外，随意访问；外用内，需要内部类对象

## 6.2 成员内部类

1. 定义格式：

```java
修饰符 class 外部类名称    {
	修饰符 class 内部类名称    {
		//…
	}
	//…
}
```

2. 如何使用成员内部类：

   - 间接方式：在外部类的方法当中，使用内部类，然后main只是调用外部类的方法

   - 直接方式：
     ```java
     类名称 对象名 = new 类名称（）；
     外部类名称.内部类名称 对象名 = new 外部类名称（）.new 内部类名称（）；
     ```
     
   - 如果出现了重名现象，那么在成员内部类中使用外部类变量名的格式是：外部类名称.this.外部类成员变量名
     
     ```java
     public class Outer {
     
     	int num = 10;//外部类的成员变量
     	
     	public class Inner{
     		int num = 20;//内部类的成员变量
     		private void methodInner() {
     			int num = 30;//内部类方法的局部变量
     			System.out.println("内部类方法的局部变量：" + num);
     			System.out.println("内部类的成员变量：" + this.num);
     			System.out.println("外部类的成员变量：" + Outer.this.num);
     			
     		}
     	}
     	
     	public static void main(String[] args) {
     		Outer.Inner obj = new Outer().new Inner();
     		obj.methodInner();
     	}
     }
     ```
     输出结果：
     ```java
     内部类方法的局部变量：30
     内部类的成员变量：20
     外部类的成员变量：10
     ```
     
     

## 6.3局部内部类（包含匿名内部类）

1. 一个类是定义在一个方法内部的

2. 定义格式：

  ```java
  修饰符 class 外部类名称    {
  	修饰符 返回类型 外部类方法名称（参数列表）{
  		class 局部内部类名称{
  			//…
  		}
  	}
  }
  ```

3. 只有当前所属的方法才能使用它，除了这个方法外面就不能用了。

4. 方法内不能直接定义静态成员

5. 如果希望访问所在方法的局部变量，那么这个局部变量必须是【有效final的】。

   即：（从Java 8 开始，只要局部变量事实不变，那么final关键字可以省略）

  ```
  1. new 出来的对象在堆内存当中
  2. 局部变量是跟着方法走的，在栈内存当中
  3. 方法运行结束之后，立刻出栈，局部变量就会立消失
  4. 但是new出来的对象会在堆当中持续存在，直到垃圾回收消失
  ```

4. public > protected > (default) > private

```
外部类：public /（default）

成员内部类：public / protected / (default) / private

局部内部类：什么都不能写（和方法内部成员使用规则一样）

匿名内部类：什么都不能写
```

## 6.4静态内部类

1. 定义格式：

```java
修饰符 class 外部类名称    {
	修饰符 static class 内部类名称    {
		//…
	}
	//…
}
```

2. 静态内部类中，只能直接访问外部类的静态成员（属性与方法），如果需要调用非静态成员，可以通过对象实例。

- 静态成员：

  ```
  1.	外部类名称.属性
  2.	外部类名称.静态方法
  ```

- 非静态成员：

  ```
  1.	new 外部类名称（）.属性
  2.	new 外部类名称（）.非静态方法
  ```

3. 静态内部类对象实例时，可以不依赖于外部类对象:

```
外部类名称.内部类名称 对象名 = new 外部类名称.内部类名称（）;
```

4. 可以通过外部类.内部类.静态成员的方式，访问内部类中的静态成员。

5. 当内部类属性与外部类属性同名时，默认直接调用内部类中的成员。

```
1. 如果需要访问外部类中的静态属性，则可以通过外部类.属性的方式；
2. 如果需要访问外部类中的非静态属性，则可以通过new 外部类（）.属性的方式；
```

## 6.5 匿名类（匿名内部类）

1. 如果接口的实现类（或者是父类的子类）只需要使用唯一的一次，那么这种情况下就可以省略掉该类的定义，而改为使用【匿名内部类】.

2. 匿名内部类: 没有类型名称、实例对象名称。

3. **定义格式：**

   ```java
   接口名称 对象名 = new 接口名称（）{ 
   	//覆盖重写所有的抽象方法
   };
   ```

4. 注意事项:

```
1. 匿名内部类，在【创建对象】的时候，只能使用唯一一次
2. 匿名内部类：没有类型名称、实例对象名称
3. 无法编写构造方法，可以添加构造代码块
4. 不能出现静态成员
5. 匿名内部类：如果希望对此创建对象，而且类的内容一样的话，可以使用单独定义的实现类

6. 匿名对象，在【调用方法】的时候，只能使用唯一一次
7. 匿名对象：如果希望同一个对象，调用多次方法，那么必须给对象起个名字。

8. 匿名内部类是省略了【实现类/子类名称】，但是匿名对象是省略了【对象名称】

9. 强调：匿名内部类和匿名对象不是一回事！！！。
```

# 七、继承

## 7.1 成员变量重名

 在父子类的继承关系当中，如果**成员变量重名**，则创建子类对象时，访问有两种方式：

- 直接通过**子类对象访问成员变量**：


```
等号左边是谁就优先用谁，没有则向上找。

编译看左，运行还看左
```

- 间接通过**成员方法访问成员变量**：
```
new的对象是谁，就优先用谁，如果没有则向上找。

编译看左，运行看右。
```
- 通过方法调用的变量的时候，方法属于谁，就调用谁的变量。

## 7.2 **访问成员方法的规则**

1. 在父子类的继承关系当中，创建子类对象，**访问成员方法的规则**：

   >  **new的对象是谁，就优先用谁，如果没有则向上找。**
   >
   >  **编译看左，运行看右**

2. 父类与子类:

   > **无论是成员方法还是成员变量，如果没有都是向上找父类，绝对不会向下找子类的。**

## 7.3 super 关键字

1. 子类的构造函数在被调用之前必须调用父类的构造函数，可以用super()来指定使用父类的哪一个构造函数。

   如果没有super()，就会默认调用父类的无参构造函数，此时如果父类没有无参构造函数，就会报错。
   
   如果子类的构造函数通过this关键字调用了本类的构造方法，这个构造方法就不会被赠送super()调用构造方法了。

2. 只有子类构造方法才能调用父类构造方法。

3. 只能调用一次super()构造方法

4. 在子类的成员方法中，访问父类的成员变量

5. 在子类的成员方法中，访问父类的成员方法

6. 在子类的构造方法中，访问父类的构造方法

## 7.4 this关键字

1. 在本类的成员方法中，访问本类的成员变量。

2. 在本类的成员方法中，访问本类的另一个成员方法。

3. 在本类的构造方法中，访问本类的另一个构造方法。

```
this(…)调用也必须是构造方法的第一条语句，唯一一个。    
super和this两种构造调用，不能同时使用。
```

## 7.5 final关键字

1. final 关键字修饰成员变量时

   - 由于成员变量具有默认值，所以用了final 之后必须手动赋值，不会再给默认值了。

   - 对于final 的成员变量，要么使用直接赋值，要么通过构造方法赋值。二者选其一。

   - 必须保证类当中所有重载的构造方法，都最终会对final的成员变量进行赋值




# 八、 接口

## 8.1 接口的注意事项

1. 接口：只能被继承，不能被new实例化

- 接口中的变量只能用 public static final 修饰，即均为常量
- 接口中的抽象方法只能用 public abstract修饰，即均为抽象方法

2. 接口不能直接使用，必须有一个“实现类”来“实现”该接口。

3. 定义格式：

```java
public class 实现类名称 implements 接口名称{
	方法体
}
```

4. 接口的实现类必须覆盖重写（实现）接口中所有的抽象方法，除非实现类是抽象类.

5. 接口是没有静态代码块与构造方法的.

6. 一个类的直接父类只能有一个,但是一个类可以同时实现多个接口。

7. 接口是可以多继承的。

## 8.2 接口的定义格式

```java
在Java 9版本中，接口的定义格式为：
public interface 接口名称 {
// ...
}
```

## 8.3接口的组成部分

### 8.3.1 常量（java7）

1. `public static final 数据类型 常量名称 = 数值;`

2. 关键字必须是public static final（可以省略）。

3. 必须赋值，不能不赋值，而且一旦赋值不能改变。

4. 常量名称完全大写，用下划线分割。

### 8.3.2 抽象方法（java7）

1. `public abstract 返回值类型 方法名称（参数列表）;`

2. 关键字必须是 public abstract,可以省略不写.

3. 方法的三要素可以随意定义.

4. **接口的实现类必须覆盖重写（实现）接口中所有的抽象方法，除非实现类是抽象类。**

### 8.3.3 默认方法（java8）

1. 写了一个接口，实现类也已经写好了，但是现在又需要增加接口的方法，可以增加默认方法。

2. 默认方法的定义格式：

```java
public default 返回值类型 方法名称（参数列表）{ 
    //方法体 
}
```
3. 可以通过接口实现类对象，直接调用（**默认继承了这个方法**）

4. 也可以被接口实现类进行覆盖重写.

### 8.3.4 静态方法（java 8)

1. 定义格式：

```java
public static 返回值类型 方法名称（参数列表）{ 
	//方法体 
}
```

2. 可以通过接口名称直接调用其中的静态方法。

3. **不能通过接口实现类的对象来调用接口当中的静态方法。**

### 8.3.5 私有方法

1. private的方法只有接口自己才能调用，不能被实现类或别人使用。

2. 普通私有方法
   - 定义格式：
   ```java
   private 返回值类型 方法名称（参数列表）{
   	//方法体 
   }
   ```
   - 给该接口的默认方法使用.
   
3. 静态私有方法

   - 定义格式：

   ```java
   private  static 返回值类型 方法名称（参数列表）{ 
   	//方法体 
   }
   ```

   - 给该接口的静态方法使用。

## 8.4 重名问题

1. 多个父接口当中的抽象方法如果重复，没关系。

2. 多个父接口当中的【默认方法】如果重复，那么子接口必须进行默认方法的覆盖重写，【而且带着default关键字】。

3. 如果一个类的直接父类当中的方法，和接口当中的方法产生了冲突，优先用父类当中的方法。

4. 如果实现类所实现的多个接口当中，存在重名的属性，要指明使用哪一个接口当中的属性。可以使用：（接口名.属性）的方法来指名。

5. 如果一个类的直接父类当中的属性，和接口当中的属性产生了冲突，会报错。可以在子类当中定义自己的属性来避免报错。

6. 接口也可以实现继承，而且可以多继承。

## 8.5 接口与实现类的使用：（上转型）

1. 定义格式：

```java
接口名称 引用名 = new 实现类名称();
```

2. 调用格式：

```java
引用名.抽象方法名(参数);
```

3. 注意事项：
   - 左边是接口类型，那么只能调用接口当中定义好的内容，不能调用右侧实现类当中特有的内容。（接口隔离）
   - 当调用接口当中的抽象方法时，真正进行运行的是右侧new的时候类的具体方法内容。
   - 总结记住一句话：**编译看左，运行看右。**



## 8.6 函数式接口

1. Java当中使用Lambda表达式的前提是：必须有“函数式接口”。

2. 有且仅有一个抽象方法的接口，叫做函数式接口。

3. 可以使用可选的**@FunctionalInterface**来检测接口是否为函数式接口，但是有没有这个注解并不影响函数式接口的定义，这只是一种**可选的检测手段**。

# 九、 多态

## 9.1 上转型与下转型

1. 上转型：其实就是多态写法

   - 父类名称 对象名 = new 子类名称（）；

   - （Cat是Animal的一个子类）

   - Animal animal= new Cat ();

   - 域与方法都以父类为准，但是如果方法被重写，以子类为准。

   - 不能访问子类相对于父类新添加的域或方法。

2. 下转型:【还原】
   - 子类名称 对象名 = （子类名称）父类对象
   - Cat cat = ( Cat ) animal;

## 9.2 格式

1. 父类名称 对象名 = new 子类名称（）；

2. 接口名称 对象名 = new 实现类名称（）；



## 9.3 多态中，成员方法的访问规则

1. 看new 的是谁，就优先用谁，没有则向上找

2. **口诀：编译看左边，运行看右边**



## 9.4 instanceof 关键字

对象 instanceof 类名称



# 十、 泛型

1. 泛型只能是引用类型，不能是基本类型.

2. 泛型方法：在方法上声明泛型:
```
情况1）：泛型类中的泛型只能适用于非静态方法如果需要给静态方法设置泛型，此时使用泛型方法

情况2）：泛型类中的泛型应该适用于整个类中多个方法有时候只对某一个方法设置泛型即可.
```







# 十一、 集合

## 10.1 ArrayList

1. 常用方法：
```
添加：public boolean add(E element)

获取：public E get(int index)

长度：public int size()

注意事项：

ArrayList集合直接打印对象名称，得到的不是地址值，而是内容，格式和数组类似。

简单了解原因：是因为ArrayList这个类其中的toString方法有特殊处理。
```
2. 对于ArrayList集合来说，添加的add动作一定是成功的，返回值必然是true。但是对于其他的集合来说，add方法就不一定成功了.

3. 在Java7 之前，即使使用new ArrayList创建对象，一个元素 都不存储，但是在堆空间依然初始化了长度位10的object数组，没必要。

   从Java7开始优化这个设计，new ArrayList，其实底层创建的使用一个空数组。
   Object []elementData = new Object[]{}；在第一次调用add方法的时候才会重新去初始化数组.



## 10.2 List集合

## 10.3 Set集合

## 10.4 Map集合

1. Map集合的特点

   - Map集合是一个双列集合，一个元素包含两个值（key,value）

   - Map集合中的元素，key和value的数据类型可以相同，也可以不同。

   - Map集合中的元素，key是不允许重复的，vlaue是可以重复的。

   - Map集合中的元素，key和value是一一对应的。
2. Map集合保证key是唯一的：作为key的元素，必须重写hashCode方法和equals方法，以保证key唯一。

## 10.5 Iterator与ListIterator

1. 使用范围不同，Iterator可以应用于所有的集合，Set、List和Map和这些集合的子类型。而**ListIterator只能用于List及其子类型。**

2. ListIterator有add()方法，可以向List中添加对象，而Iterator不能.

3. ListIterator和Iterator都有hasNext()和next()方法，可以实现顺序向后遍历，但是ListIterator有hasPrevious()和previous()方法，可以实现逆向（顺序向前）遍历。Iterator就不可以。

4. ListIterator可以定位当前的索引位置，nextIndex()和previousIndex()可以实现。Iterator没有此功能。

5. 都可实现删除对象，但是ListIterator可以实现对象的修改，set()方法可以实现。Iierator仅能遍历，不能修改。

6. 深入分析for each和迭代器:
   > 1. foreach可以操作数组：底层依然采用or循环+索引来获取数组元素.
   >
   > 2. foreach可以操作Iterable的实例：底层其实采用的terator（迭代器）.
   > 3. 直接使用foreach迭代数组和集合元素即可，简单

7. 当需要边迭代集合元素，边删除指定的元素时：此时只能使用迭代器，而且只能使用迭代器对象的remove方法

## 10.6 日常数据结构使用什么类

1. 数组：ArrayList

2. 队列: 
   - Queue:队列：将元素添加到双端队列的末尾，从双端队列的开头移除元素。
   **LinkedList,ArrayDeque,PriorituQueue**
   ![](https://gitee.com/heathhou/image_store/raw/master/分类/Java/java_care/20200808213254.png)
   
   - Deque:双端队列：将元素添加到双端队列的末尾，从双端队列的开头移除元素。
   **LinkedList,ArrayDeque**
   ![](https://gitee.com/heathhou/image_store/raw/master/分类/Java/java_care/20200808213311.png)
   
   ![](https://gitee.com/heathhou/image_store/raw/master/分类/Java/java_care/20200808213402.png)

3. 栈：**ArrayDeque**,LinkedList
   ![](https://gitee.com/heathhou/image_store/raw/master/分类/Java/java_care/20200808213447.png)



## 10.7 集合排序

1. Comparable接口的排序规则：自己（this) - 参数：升序

2. **Comparable和Comparator**的区别:

- **Comparable：**自然排序

```java
1. int compareTo(T o)  
2. 使用前提：被排序的集合里边存储的元素，必须实现Comparable，重写接口中的方法int compareTo（T o）定义排序的规则。
3. 自己（this）和别人（参数）比较，自己需要实现Comparable接口，重写比较的规则compareTo方法
4. Comparable接口的排序规则：自己（this） - 参数：升序
```

- **Comparator: **定制排序
```java
1. int compare(T o1, T o2)  
2. 重写Comparator接口中的compare(T o1,T o2)方法
3. 相当于找一个第三方的裁判
4. Comparator接口的排序规则：o1 – o2:升序
```

## 10.8 其他注意

1. Vector的默认初始容量为10；

2. HashMap,TreeMap,LinkedHashMap都是线程不安全的，但是性能较高。

3. HashSet,ArrayList,HashMap都是线程不安全的。

### 10.8.1 Hashtable 与 HashMap

1. Hashtable: 底层是一个哈希表, 是一个线程安全的集合，单线程集合，速度慢。是HashMap的前身，打死不用。

2. HashMap: 底层是一个哈希表,是一个线程不安全的集合，是多线程的集合，速度快








# 十二、常用类

## 12.1 Date

1. 在类 Date 所有可以接受或返回年、月、日期、小时、分钟和秒值的方法中，将使用下面的表示形式：

- 年份 *y* 由整数 *y* - 1900 表示。 

- 月份由从 0 至 11 的整数表示；0 是一月、1 是二月等等；因此 11 是十二月。 

- **日期**（一月中的某天）按通常方式由整数 **1 至 31 表示**。 

- 小时由从 0 至 23 的整数表示。因此，从午夜到 1 a.m. 的时间是 0 点，从中午到 1 p.m. 的时间是 12 点。 

- 分钟按通常方式由 0 至 59 的整数表示。 

- 秒由 0 至 61 的整数表示；值 60 和 61 只对闰秒发生，尽管那样，也只用在实际正确跟踪闰秒的 Java 实现中。于按当前引入闰秒的方式，两个闰秒在同一分钟内发生是极不可能的，但此规范遵循 ISO C 的日期和时间约定。 

- 星期（DAY_OF_WEEK）：周日是1，周一是2，…周六是7

## 12.2 String

1. 直接使用双引号的字符串默认在字符串池中，而new出来的字符串默认不在字符串池中。

2. 字符串对象一旦被创建，内容不可改变。

## 12.3 Collections工具类

1. java.utils.**Collections**是集合工具类，用来对集合进行操作。

2. static <T extends Comparable<? super T>> void sort(List<T> list)		
   - 使用前提：被排序的集合里边存储的元素，必须实现Comparable，重写接口中的方法compareTo定义排序的规则。


3. static <T> Collection<T> synchronizedCollection(Collection<T> c) 
   - 返回指定 collection 支持的同步（线程安全的）collection。
   
    
4. static <T> Collection<T> synchronizedCollection(Collection<T> c) 
   - 返回指定 collection 支持的同步（线程安全的）collection。 



## 12.4 Calendar

1. **日期**（一月中的某天）按通常方式由整数 **1 至 31 表示**。 

## 12.5 Arrays工具类

1. static <T> List<T> asList(T... a) 
   
- 返回一个受指定数组支持的固定大小的列表。 
  
2. static String toString(boolean[] a) 

      - 返回指定数组内容的字符串表示形式。 
3. static void sort(byte[] a) 

      - 对指定的 byte 型数组按数字升序进行排序。
